#include <furoo.h>
#include <gtest/gtest.h>

using namespace furoo;

TEST(LinearSolver, bicg) {
  LinearMatrix m(8, 8);
  m(0, 0) = 3.100;
  m(0, 1) = -1.000;
  m(0, 2) = -1.000;
  m(0, 5) = -1.000;
  m(1, 0) = -1.000;
  m(1, 1) = 4.000;
  m(1, 2) = -1.000;
  m(1, 4) = -1.000;
  m(1, 6) = -1.000;
  m(2, 0) = -1.000;
  m(2, 1) = -1.000;
  m(2, 2) = 5.000;
  m(2, 3) = -1.000;
  m(2, 5) = -1.000;
  m(2, 7) = -1.000;
  m(3, 2) = -1.000;
  m(3, 3) = 4.100;
  m(3, 4) = -1.000;
  m(3, 5) = -1.000;
  m(3, 6) = -1.000;
  m(4, 1) = -1.000;
  m(4, 3) = -1.000;
  m(4, 4) = 4.500;
  m(4, 5) = -1.000;
  m(4, 7) = -1.000;
  m(5, 0) = -1.000;
  m(5, 2) = -1.000;
  m(5, 3) = -1.000;
  m(5, 4) = -1.000;
  m(5, 5) = 5.000;
  m(5, 6) = -1.000;
  m(6, 1) = -1.000;
  m(6, 3) = -1.000;
  m(6, 5) = -1.000;
  m(6, 6) = 3.500;
  m(6, 7) = -1.000;
  m(7, 2) = -1.000;
  m(7, 4) = -1.000;
  m(7, 6) = -1.000;
  m(7, 7) = 3.300;
  std::vector<double> b(8, 0.f);
  b[0] = 0.100;
  b[3] = 0.100;
  b[4] = 0.500;
  b[6] = -0.500;
  b[7] = 0.300;
  LinearVector B(b);
  LinearVector x(b.size());
  BiconjugateGradientLinearSolver bicg;
  bicg.solve(&m, &B, &x);
  for (size_t i = 0; i < x.size(); i++)
    ASSERT_NEAR(x[i], 1.0, 1e-8);
}

TEST(LinearSolver, bicg_homogeneos) {
  std::vector<double> v = {
      1, 0,  0, 0, 0,  0,   0,  0,  0,  0,   0,  0,   0,  0,   0,  0,   0,  1,
      0, 0,  0, 0, 0,  0,   0,  0,  0,  0,   0,  0,   0,  0,   0,  0,   1,  0,
      0, 0,  0, 0, 0,  0,   0,  0,  0,  0,   0,  0,   0,  0,   0,  1,   0,  0,
      0, 0,  0, 0, 0,  0,   0,  0,  0,  0,   0,  0,   0,  0,   1,  0,   0,  0,
      0, 0,  0, 0, 0,  0,   0,  0,  0,  16,  0,  0,   16, -64, 16, 0,   0,  16,
      0, 0,  0, 0, 0,  16,  0,  0,  16, -64, 16, 0,   0,  16,  0,  0,   0,  0,
      0, 0,  0, 0, 0,  1,   0,  0,  0,  0,   0,  0,   0,  0,   0,  0,   0,  0,
      0, 0,  0, 0, 1,  0,   0,  0,  0,  0,   0,  0,   0,  0,   0,  0,   1,  0,
      0, 0,  0, 0, 0,  0,   0,  0,  0,  0,   0,  16,  0,  0,   16, -64, 16, 0,
      0, 16, 0, 0, 0,  0,   0,  16, 0,  0,   16, -64, 16, 0,   0,  16,  0,  0,
      0, 0,  0, 0, 0,  16,  0,  0,  16, -64, 16, 0,   0,  0,   0,  0,   0,  0,
      0, 16, 0, 0, 16, -64, 16, 0,  0,  0,   0,  0,   0,  0,   0,  0,   0,  0,
      0, 1,  0, 0, 0,  0,   0,  0,  0,  0,   0,  0,   0,  0,   0,  0,   0,  0,
      1, 0,  0, 0, 0,  0,   0,  0,  0,  0,   0,  0,   0,  0,   0,  0,   0,  1,
      0, 0,  0, 0, 0,  0,   0,  0,  0,  0,   0,  0,   0,  0,   0,  0,   1,  0,
      0, 0,  0, 0, 0,  0,   0,  0,  0,  0,   0,  0,   0,  0,   0,  1};
  LinearMatrix A(16, 16, v);
  LinearVector x(std::vector<double>(16, 0));
  LinearVector b(std::vector<double>(16, 0));
  BiconjugateGradientLinearSolver bicg;
  bicg.solve(&A, &b, &x);
  for (size_t i = 0; i < x.size(); i++)
    ASSERT_NEAR(x[i], 0., 1e-8);
}

TEST(LinearSolver, cg) {
  {
    LinearMatrix A(2, 2);
    A(0, 0) = 4;
    A(0, 1) = 1;
    A(1, 0) = 1;
    A(1, 1) = 3;
    LinearVector b(2);
    b[0] = 1;
    b[1] = 2;
    LinearVector x(2);
    x[0] = 2;
    x[1] = 1;
    ConjugateGradientLinearSolver solver;
    bool r = solver.solve(&A, &b, &x);
    EXPECT_EQ(r, true);
    ASSERT_NEAR(x[1], 7. / 11., 1e-8);
  }
  {
    LinearMatrix m(8, 8);
    m(0, 0) = 3.100;
    m(0, 1) = -1.000;
    m(0, 2) = -1.000;
    m(0, 5) = -1.000;
    m(1, 0) = -1.000;
    m(1, 1) = 4.000;
    m(1, 2) = -1.000;
    m(1, 4) = -1.000;
    m(1, 6) = -1.000;
    m(2, 0) = -1.000;
    m(2, 1) = -1.000;
    m(2, 2) = 5.000;
    m(2, 3) = -1.000;
    m(2, 5) = -1.000;
    m(2, 7) = -1.000;
    m(3, 2) = -1.000;
    m(3, 3) = 4.100;
    m(3, 4) = -1.000;
    m(3, 5) = -1.000;
    m(3, 6) = -1.000;
    m(4, 1) = -1.000;
    m(4, 3) = -1.000;
    m(4, 4) = 4.500;
    m(4, 5) = -1.000;
    m(4, 7) = -1.000;
    m(5, 0) = -1.000;
    m(5, 2) = -1.000;
    m(5, 3) = -1.000;
    m(5, 4) = -1.000;
    m(5, 5) = 5.000;
    m(5, 6) = -1.000;
    m(6, 1) = -1.000;
    m(6, 3) = -1.000;
    m(6, 5) = -1.000;
    m(6, 6) = 3.500;
    m(6, 7) = -1.000;
    m(7, 2) = -1.000;
    m(7, 4) = -1.000;
    m(7, 6) = -1.000;
    m(7, 7) = 3.300;
    std::vector<double> b(8, 0.f);
    b[0] = 0.100;
    b[3] = 0.100;
    b[4] = 0.500;
    b[6] = -0.500;
    b[7] = 0.300;
    LinearVector B(b);
    LinearVector x(b.size());
    ConjugateGradientLinearSolver cg;
    cg.solve(&m, &B, &x);
    for (size_t i = 0; i < x.size(); i++)
      ASSERT_NEAR(x[i], 1.0, 1e-8);
  }
}

TEST(LinearSolver, gaussj) {
  {
    LinearMatrix A(2, 2);
    A(0, 0) = -1;
    A(0, 1) = 4;
    A(1, 0) = 0.2;
    A(1, 1) = -8;
    LinearVector b(2);
    b[0] = 2;
    b[1] = 10;
    GaussJordanLinearSolver solver;
    bool r = solver.solve(&A, &b, &b);
    EXPECT_EQ(r, true);
  }
  LinearMatrix A(8, 8);
  A(0, 0) = 3.1;
  A(0, 1) = -1.0;
  A(0, 2) = -1.0;
  A(0, 5) = -1.0;
  A(1, 0) = -1.0;
  A(1, 1) = 4.0;
  A(1, 2) = -1.0;
  A(1, 4) = -1.0;
  A(1, 6) = -1.0;
  A(2, 0) = -1.0;
  A(2, 1) = -1.0;
  A(2, 2) = 5.0;
  A(2, 3) = -1.0;
  A(2, 5) = -1.0;
  A(2, 7) = -1.0;
  A(3, 2) = -1.0;
  A(3, 3) = 4.1;
  A(3, 4) = -1.0;
  A(3, 5) = -1.0;
  A(3, 6) = -1.0;
  A(4, 1) = -1.0;
  A(4, 3) = -1.0;
  A(4, 4) = 4.5;
  A(4, 5) = -1.0;
  A(4, 7) = -1.0;
  A(5, 0) = -1.0;
  A(5, 2) = -1.0;
  A(5, 3) = -1.0;
  A(5, 4) = -1.0;
  A(5, 5) = 5.0;
  A(5, 6) = -1.0;
  A(6, 1) = -1.0;
  A(6, 3) = -1.0;
  A(6, 5) = -1.0;
  A(6, 6) = 3.5;
  A(6, 7) = -1.0;
  A(7, 2) = -1.0;
  A(7, 4) = -1.0;
  A(7, 6) = -1.0;
  A(7, 7) = 3.3;
  LinearVector b(8);
  b[0] = 0.1;
  b[3] = 0.1;
  b[4] = 0.5;
  b[6] = -0.5;
  b[7] = 0.3;
  {
    GaussJordanLinearSolver solver;
    bool r = solver.solve(&A, &b, &b);
    EXPECT_EQ(r, true);
    for (size_t i = 0; i < b.size(); i++)
      ASSERT_NEAR(b[i], 1.0, 1e-8);
  }
}
